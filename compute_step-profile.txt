Source Line  Source                                                                           CPU Time  Spin Time  Overhead Time
-----------  -------------------------------------------------------------------------------  --------  ---------  -------------
155              std::vector<vec> gy_;           // y differences of g
156              std::vector<vec> v_;            // Solution values at next step
157
158              // Array accessor functions
159
160              int offset(int ix, int iy) const { return iy*nx_all+ix; }
161
162              vec& u(int ix, int iy)    { return u_[offset(ix,iy)]; }
163              vec& v(int ix, int iy)    { return v_[offset(ix,iy)]; }
164              vec& f(int ix, int iy)    { return f_[offset(ix,iy)]; }
165              vec& g(int ix, int iy)    { return g_[offset(ix,iy)]; }
166
167              vec& ux(int ix, int iy)   { return ux_[offset(ix,iy)]; }
168              vec& uy(int ix, int iy)   { return uy_[offset(ix,iy)]; }
169              vec& fx(int ix, int iy)   { return fx_[offset(ix,iy)]; }
170              vec& gy(int ix, int iy)   { return gy_[offset(ix,iy)]; }
171
172              // Wrapped accessor (periodic BC)
173              int ioffset(int ix, int iy) {
174                  return offset( (ix+nx-nghost) % nx + nghost,
175                                 (iy+ny-nghost) % ny + nghost );
176              }
177
178              vec& uwrap(int ix, int iy)  { return u_[ioffset(ix,iy)]; }
179
180              // Apply limiter to all components in a vector
181              static void limdiff(vec& du, const vec& um, const vec& u0, const vec& up) {
182                  for (int m = 0; m < du.size(); ++m)
183                      du[m] = Limiter::limdiff(um[m], u0[m], up[m]);
184              }
185
186              // Stages of the main algorithm
187              void apply_periodic();
188              void compute_fg_speeds(real& cx, real& cy);
189              void limited_derivs();
190              void compute_step(int io, real dt);
191
192          };
193
194
195          /**
196           * ## Initialization
197           *
198           * Before starting the simulation, we need to be able to set the
199           * initial conditions.  The `init` function does exactly this by
200           * running a callback function at the center of each cell in order
201           * to initialize the cell $U$ value.  For the purposes of this function,
202           * cell $(i,j)$ is the subdomain
203           * $[i \Delta x, (i+1) \Delta x] \times [j \Delta y, (j+1) \Delta y]$.
204           */
205
206          template <class Physics, class Limiter>
207          template <typename F>
208          void Central2D<Physics, Limiter>::init(F f)
209          {
210              for (int iy = 0; iy < ny; ++iy)
211                  for (int ix = 0; ix < nx; ++ix)
212                      f(u(nghost+ix,nghost+iy), (ix+0.5)*dx, (iy+0.5)*dy);
213          }
214
215          /**
216           * ## Time stepper implementation
217           *
218           * ### Boundary conditions
219           *
220           * In finite volume methods, boundary conditions are typically applied by
221           * setting appropriate values in ghost cells.  For our framework, we will
222           * apply periodic boundary conditions; that is, waves that exit one side
223           * of the domain will enter from the other side.
224           *
225           * We apply the conditions by assuming that the cells with coordinates
226           * `nghost <= ix <= nx+nghost` and `nghost <= iy <= ny+nghost` are
227           * "canonical", and setting the values for all other cells `(ix,iy)`
228           * to the corresponding canonical values `(ix+p*nx,iy+q*ny)` for some
229           * integers `p` and `q`.
230           */
231
232          template <class Physics, class Limiter>
233          void Central2D<Physics, Limiter>::apply_periodic()
234          {
235              // Copy data between right and left boundaries
236              for (int iy = 0; iy < ny_all; ++iy)
237                  for (int ix = 0; ix < nghost; ++ix) {
238                      u(ix,          iy) = uwrap(ix,          iy);
239                      u(nx+nghost+ix,iy) = uwrap(nx+nghost+ix,iy);
240                  }
241
242              // Copy data between top and bottom boundaries
243              for (int ix = 0; ix < nx_all; ++ix)
244                  for (int iy = 0; iy < nghost; ++iy) {
245                      u(ix,          iy) = uwrap(ix,          iy);
246                      u(ix,ny+nghost+iy) = uwrap(ix,ny+nghost+iy);
247                  }
248          }
249
250
251          /**
252           * ### Initial flux and speed computations
253           *
254           * At the start of each time step, we need the flux values at
255           * cell centers (to advance the numerical method) and a bound
256           * on the wave speeds in the $x$ and $y$ directions (so that
257           * we can choose a time step that respects the specified upper
258           * bound on the CFL number).
259           */
260
261          template <class Physics, class Limiter>
262          void Central2D<Physics, Limiter>::compute_fg_speeds(real& cx_, real& cy_)
263          {
264              using namespace std;
265              real cx = 1.0e-15;
266              real cy = 1.0e-15;
267              for (int iy = 0; iy < ny_all; ++iy)
268                  for (int ix = 0; ix < nx_all; ++ix) {
269                      real cell_cx, cell_cy;
270                      Physics::flux(f(ix,iy), g(ix,iy), u(ix,iy));
271                      Physics::wave_speed(cell_cx, cell_cy, u(ix,iy));
272                      cx = max(cx, cell_cx);
273                      cy = max(cy, cell_cy);
274                  }
275              cx_ = cx;
276              cy_ = cy;
277          }
278
279          /**
280           * ### Derivatives with limiters
281           *
282           * In order to advance the time step, we also need to estimate
283           * derivatives of the fluxes and the solution values at each cell.
284           * In order to maintain stability, we apply a limiter here.
285           */
286
287          template <class Physics, class Limiter>
288          void Central2D<Physics, Limiter>::limited_derivs()
289          {
290              for (int iy = 1; iy < ny_all-1; ++iy)
291                  for (int ix = 1; ix < nx_all-1; ++ix) {
292
293                      // x derivs
294                      limdiff( ux(ix,iy), u(ix-1,iy), u(ix,iy), u(ix+1,iy) );
295                      limdiff( fx(ix,iy), f(ix-1,iy), f(ix,iy), f(ix+1,iy) );
296
297                      // y derivs
298                      limdiff( uy(ix,iy), u(ix,iy-1), u(ix,iy), u(ix,iy+1) );
299                      limdiff( gy(ix,iy), g(ix,iy-1), g(ix,iy), g(ix,iy+1) );
300                  }
301          }
302
303
304          /**
305           * ### Advancing a time step
306           *
307           * Take one step of the numerical scheme.  This consists of two pieces:
308           * a first-order corrector computed at a half time step, which is used
309           * to obtain new $F$ and $G$ values; and a corrector step that computes
310           * the solution at the full step.  For full details, we refer to the
311           * [Jiang and Tadmor paper][jt].
312           *
313           * The `compute_step` function takes two arguments: the `io` flag
314           * which is the time step modulo 2 (0 if even, 1 if odd); and the `dt`
315           * flag, which actually determines the time step length.  We need
316           * to know the even-vs-odd distinction because the Jiang-Tadmor
317           * scheme alternates between a primary grid (on even steps) and a
318           * staggered grid (on odd steps).  This means that the data at $(i,j)$
319           * in an even step and the data at $(i,j)$ in an odd step represent
320           * values at different locations in space, offset by half a space step
321           * in each direction.  Every other step, we shift things back by one
322           * mesh cell in each direction, essentially resetting to the primary
323           * indexing scheme.
324           */
325
326          template <class Physics, class Limiter>
327          void Central2D<Physics, Limiter>::compute_step(int io, real dt)
328          {
329              real dtcdx2 = 0.5 * dt / dx;
330              real dtcdy2 = 0.5 * dt / dy;
331
332              // Predictor (flux values of f and g at half step)
333              for (int iy = 1; iy < ny_all-1; ++iy)
334                  for (int ix = 1; ix < nx_all-1; ++ix) {                                    0.001s         0s             0s
335                      vec uh = u(ix,iy);                                                     0.006s         0s             0s
336                      for (int m = 0; m < uh.size(); ++m) {
337                          uh[m] -= dtcdx2 * fx(ix,iy)[m];
338                          uh[m] -= dtcdy2 * gy(ix,iy)[m];                                    0.032s         0s             0s
339                      }
340                      Physics::flux(f(ix,iy), g(ix,iy), uh);
341                  }
342
343              // Corrector (finish the step)
344              for (int iy = nghost-io; iy < ny+nghost-io; ++iy)
345                  for (int ix = nghost-io; ix < nx+nghost-io; ++ix) {                        0.013s         0s             0s
346                      for (int m = 0; m < v(ix,iy).size(); ++m) {
347                          v(ix,iy)[m] =                                                      0.128s         0s             0s
348                              0.2500 * ( u(ix,  iy)[m] + u(ix+1,iy  )[m] +                   0.007s         0s             0s
349                                         u(ix,iy+1)[m] + u(ix+1,iy+1)[m] ) -                 0.046s         0s             0s
350                              0.0625 * ( ux(ix+1,iy  )[m] - ux(ix,iy  )[m] +
351                                         ux(ix+1,iy+1)[m] - ux(ix,iy+1)[m] +
352                                         uy(ix,  iy+1)[m] - uy(ix,  iy)[m] +
353                                         uy(ix+1,iy+1)[m] - uy(ix+1,iy)[m] ) -               0.015s         0s             0s
354                              dtcdx2 * ( f(ix+1,iy  )[m] - f(ix,iy  )[m] +
355                                         f(ix+1,iy+1)[m] - f(ix,iy+1)[m] ) -                 0.033s         0s             0s
356                              dtcdy2 * ( g(ix,  iy+1)[m] - g(ix,  iy)[m] +                   0.012s         0s             0s
357                                         g(ix+1,iy+1)[m] - g(ix+1,iy)[m] );                  0.036s         0s             0s
358                      }
359                  }
360
361              // Copy from v storage back to main grid
362              for (int j = nghost; j < ny+nghost; ++j){
363                  for (int i = nghost; i < nx+nghost; ++i){                                  0.008s         0s             0s
364                      u(i,j) = v(i-io,j-io);                                                 0.013s         0s             0s
365                  }
366              }
367          }
368
369
370          /**
371           * ### Advance time
372           *
