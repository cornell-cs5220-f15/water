\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Profiling}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Vectorization}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Vectorizing C}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Domain Decomposition}{3}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces Domain decomposition}}{4}}
\newlabel{alg:a1}{{1}{4}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces Domain decomposition with parallel speed computation}}{5}}
\newlabel{alg:a2}{{2}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Offloading to The Phis}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Results}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Strong scaling speedup for running on the Xeon E5 2620s. Baseline for calculating speedup is Professor Bindel's code from the point at which we forked it.}}{7}}
\newlabel{fig:strong-e5}{{1}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}Xeon E5 Performance}{7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.1.1}Weak Scaling}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Weak scaling speedup for running on the Xeon E5 2620s. Baseline for calculating speedup is Professor Bindel's code from the point at which we forked it.}}{8}}
\newlabel{fig:weak-e5}{{2}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Strong scaling speedup for our offloaded Phi code. Baseline for calculating speedup is Professor Bindel's code from the point at which we forked it.}}{8}}
\newlabel{fig:strong-mic-bindel}{{3}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}Xeon Phi Performance}{8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.1}Strong Scaling}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Strong scaling speedup for our offloaded Phi code. Baseline for calculating speedup is our code running a single thread offloaded to the Phis.}}{9}}
\newlabel{fig:strong-mic-mic}{{4}{9}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.2}Weak Scaling}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Weak scaling speedup for our offloaded Phi code. Baseline for calculating speedup is Professor Bindel's code from the point at which we forked it.}}{10}}
\newlabel{fig:weak-mic}{{5}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Batch size Performance}{10}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Strong scaling speedup for our offloaded Phi code with a batch size of 2. Baseline for calculating speedup is Professor Bindel's code at the point where we forked it. We can see that speedup is slightly worse than our speedup for batch size of 1.}}{10}}
\newlabel{fig:batch2}{{6}{10}}
